# 7. 스프링 핵심 기술의 응용

- IoC/DI, 서비스 추상화, AOP등 스프링의 모든 기술은 결국 객체지향적인 언어의 장점을 적극적으로 활용해서 코드를 작성하도록 도와주는 것이다.
- 지금까지 살펴봤던 세 가지 기술을 애플리케이션 개발에 활용해서 새로운 기능을 만들어보고 이를 통해 스프링의 개발철학과 추구하는 가치, 스프링 사용자에게 요구되는 게 무엇인지를 살펴보겠다.

# 7.1 SQL과 DAO의 분리

- `UserDao`를 지금까지 충분히 다듬고 개선해왔다.
- 하지만 SQL을 완전히 제거하진 못했다.
- 데이터를 가져오고 조작하는 작업의 인터페이스 역할을 하는 것이 DAO다.
- DAO인터페이스가 바뀌지 않고, JDBC라는 처리 기술도 바뀌지 않으며, 정보를 담을 오브젝트가 바뀌지 않는다면 DAO 코드가 바뀔 이유는 없다.
- 하지만 DB의 테이블, 필드 이름과 SQL문장은 바뀔 수 있다.
- 테이블 분리, 쿼리 최적화 등 어떤 이유에서든지 SQL 변경이 필요한 상황이 발생하면 SQL을 담고 있는 DAO 코드가 수정될 수밖에 없다.

## 7.1.1 XML 설정을 이용한 분리

- 가장 손쉽게 생각해볼 수 있는 SQL 분리 방법은 SQL을 스프링의 XML 설정파일로 빼내는 것이다.
- SQL은 문자열로 되어 있으니 설정파일에 프로퍼티 값으로 정의해서 DAO에 주입해줄 수 있다.

### 개별 SQL 프로퍼티 방식

- XML 설정파일에 각 쿼리 메서드에 사용될 SQL 문자열을 프로퍼티로 정의해서 DI받게 하면 된다.

### SQL 맵 프로퍼티 방식

- SQL이 점점 많아지면 그때마다 XML 설정파일에 DAO에 DI용 프로퍼티를 추가하기가 상당히 귀찮다.
- Map 컬렉션을 이용하여 XML 설정파일에 쉽게 `<entry>`를 이용하여 추가하게 하면 편리하다.

![](list-7-6-1.jpeg)
![](list-7-6-2.jpeg)

## 7.1.2 SQL 제공 서비스

- 지금까지의 방법은 몇 가지 문제점이 있다.

1. SQL과 DI 설정정보가 섞여 있으면 보기에도 지저분하고 관리하기도 좋지 않다.
    - SQL을 따로 분리해둬야 독립적으로 SQL 문의 리뷰나 튜닝 작업이 수월하다.
2. SQL을 꼭 스프링의 빈 설정 방법으로 XML에 담아둘 이유도 없다.
    - SQL을 편집하고 관리할 수 있는 툴에서 생성해주는 SQL 정보 파일이 있다면, 그런 파일 포맷 그대로 사용할 수 있어야 편할 것이다.
3. 스프링의 설정파일로부터 생성된 오브젝트와 정보는 애플리케이션을 다시 시작하기 전에는 변경이 매우 어렵다는 점도 문제다.
    - 주입된 SQL 맵 오브젝트를 직접 변경하는 방법을 생각해볼 수는 있겠지만 싱글톤인 DAO의 인스턴스 변수에 접근해서 실시간으로 내용을 수정하는 건 간단한 일이 아니다.
    - 운영중인 애프리케이션에 빈번하게 참조되는 Map 내용을 수정할 경우 동시성 문제를 일으킬 수도 있다.
- 이런 문제점들을 해결하고 요구사항을 모두 충족하려면 DAO가 사용할 SQL을 제공해주는 기능을 독립시킬 필요가 있다.
- SQL 제공 기능을 본격적으로 분리해서 다양한 SQL 정보 소스를 사용할 수 있고, 운영 중에 동적으로 갱신도 가능한 유연하고 확장성이 뛰어난 SQL 서비스를 만들어보자.

### SQL 서비스 인터페이스

- 가장 먼저 할 일은 SQL 서비스의 인터페이스를 설계하는 것이다.

![](list-7-7.jpeg)

- 주어진 키를 가지고 SQL을 가져오다가 어떤 이유에서든지 실패하는 경우에는 `SqlRetrievalFailureException` 예외를 던지도록 정의한다.

![](list-7-8.jpeg)

- 이제 `UserDaoJdbc`는 `SqlService` 인터페이스를 통해 필요한 SQL을 가져와 사용할 수 있게 만들어준다.

![](list-7-9.jpeg)

- 이제 모든 메서드에서 인스턴스 변수인 `sqlService`를 이용해 SQL을 가져오도록 수정한다.

![](list-7-10.jpeg)

### 스프링 설정을 사용하는 단순 SQL 서비스

- `SqlService` 인터페이스에는 어떤 기술적인 조건이나 제약사항도 담겨 있지 않다.
- 어떤 방법을 사용하든 상관없이 DAO가 요구하는 SQL을 돌려주기만 하면 된다.
- 일단 가장 간단한 방법으로 `SqlService`를 구현해보자.

![](list-7-11.jpeg)

- `SimpleSqlService` 클래스를 빈으로 등록하고 UserDao가 DI 받아 사용하도록 설정해준다.

![](none-1.jpeg)

- 현재 코드와 설정만 놓고 보자면 앞에서 사용했던 방법과 별로 다를 게 없어 보인다.
- 하지만 큰 차이가 있는데, 이제 `UserDao`를 포함한 모든 DAO는 SQL을 어디에 저장해두고 가져오는지에 대해서는 전혀 신경 쓰지 않아도 된다.
- 구체적인 구현 방법과 기술에 상관없이 `SqlService` 인터페이스 타입의 빈을 DI 받아서 필요한 SQL을 가져다 쓰기만 하면 된다.
- 동시에 `sqlService` 빈에는 DAO에는 전혀 영향을 주지 않은 채로 다양한 방법으로 구현된 `sqlService` 타입 클래스를 적용할 수 있다.

# 7.2 인터페이스의 분리와 자기참조 빈

- 이제 `SqlService` 인터페이스의 구현 방법을 고민해보자.
- 인터페이스가 하나 있으니 기계적으로 구현 클래스 하나만 만들면 될 거라고 생각하면 오산이다.
- 어떤 인터페이스는 그 뒤에 숨어 있는 방대한 서브시스템의 관문에 불과할 수도 있다.
- 인터페이스로 대표되는 기능을 구현 방법과 확장 가능성에 따라 유연한 방법으로 재구성할 수 있도록 설계할 필요도 있다.

## 7.2.1 XML 파일 매핑

- 스프링의 XML 설정파일에서 `<bean>` 태그 안에 SQL 정보를 넣어놓고 활용하는 건 좋은 방법이 아니다.
- 그보다는 SQL을 저장해두는 전용 포맷을 가진 독립적인 파일을 이용하는 편이 바람직하다.

> 이하는 `JAXB`를 이용하여 XML 파일을 읽는 과정에 관한 설명이므로 정리를 생략합니다.
> 핵심은 스프링의 설정 파일이 아닌 독립된 XML파일에 쿼리를 저장하고, 이를 스프링에서 어떻게 불러올 것인지 입니다.

## 7.2.4 변화를 위한 준비: 인터페이스 분리

- 위에서 만든 `XmlSqlService`는 특정 포맷의 XML에서 SQL 데이터를 가져오고, 이를 `HashMap` 타입의 맵 오브젝트에 저장해둔다.
- SQL을 가져오는 방법에 있어서는 특정 기술에 고정되어 있다.
- XML 대신 다른 포맷의 파일에서 SQL을 읽어오게 하려면 어떻게 해야 할까?
- 지금 구조에서라면 `SqlService` 인터페이스를 구현하는 완전히 새로운 클래스를 처음부터 만들거나  `XmlSqlService`의 코드를 직접 뜯어고쳐야 한다.
- SQL을 가져오는 것과 보관해두고 사용하는 것은 충분히 독자적인 이유로 변경 가능한 독립적인 전략이다.
- 서로 변하는 시기와 성질이 다른 것, 변하는 것과 변하지 않는 것을 함께 두는 건 바람직한 설계구조가 아니다.

### 책임에 따른 인터페이스 정의

- 가장 먼저 할 일은 분리 가능한 관심사를 구분해보는 것이다.
- `XmlSqlService` 구현을 참고해서 독립적으로 변경 가능한 책임을 뽑아보자.

1. SQL 정보를 외부의 리소스로부터 읽어오는 것이다.
    - 리소스는 텍스트 파일일수도, XML일수도, 엑셀 파일일수도, DB일수도 있다.
2. 읽어온 SQL을 보관해두고 있다가 필요할 때 제공해주는 것이다.
    - 여기에 좀 더 부가적인 책임을 생각해볼 수 있다.
    - 일단 서비스를 위해서 한 번 가져온 SQL을 필요에 따라 수정할 수 있게 하는 것이다.
    - 시스템 운영 중에 서버를 재시작하거나 애플리케이션을 재설치하지 않고도 SQL을 긴급히 변경해야 하는 경우가 있다.
    - 이를 위해 필요하다면 사용 중인 SQL을 수정하는 기능도 생각해볼 수 있다.

- 이 두 가지 책임을 어떻게 조합해서 사용할지를 생각해보자.
- 기본적으로 `SqlService`를 구현해서 DAO에 서비스를 제공해주는 오브젝트가 이 두 가지 책임을 가진 오브젝트와 협력해서 동작하도록 만들어야 한다.
- 변경 가능한 기능은 전략 패턴을 적용해 별도의 오브젝트로 분리해줘야 한다.
- `SqlReader`와 `SqlRegistry` 두 가지 타입의 오브젝트를 사용하도록 만든다.
- 물론 인터페이스로 정의해야 한다.

![](picture-7-3.jpeg)

- 인터페이스를 실제로 정의하기 전에 한 가지 생각해볼 사항이 있다.
- `SqlReader`가 읽어오는 SQL 정보는 다시 `SqlRegistry`에 전달해서 등록되게 해야 한다.
- SQL을 `SqlReader`에서 `SqlRegistry`로 전달하는 과정과 전달되는 형식을 어떻게 할지 생각해보자.
- `SqlReader`가 가져올 내용은 간단하니 간단히 SQL과 키를 쌍으로 하는 배열을 만들고, 이를 다시 리스트에 담아서 가져오거나 지금까지 많이 써왔던 방식대로 맵을 이용할 수 있다.
- `SqlReader`가 리소스로부터 읽어온 SQL 정보를 맵으로 돌려준다고 정의하면 `SqlService` 구현 클래스에서는 아래와 같은 코드가 만들어질 것이다.

![](list-7-27.jpeg)

- 이 방식은 번거로워 보인다.
    - `sqlRegistry`로 전달하기 위해 임시로 데이터를 만들어서 넘겨줘야 하기 때문이다.
- 조금만 생각을 바꿔보면, 굳이` SqlService`가 `SqlReader`로부터 정보를 받은 뒤 `SqlRegistry`에 다시 전달해줘야 할 필요는 없다.
- `SqlReader`가 `SqlRegistry` 전략을 제공해주면서 이를 이용해 SQL 정보를 `SqlRegistry`에 저장하라고 요청하는 편이 낫다.

![](list-7-28.jpeg)
![](list-7-29.jpeg)

- 이렇게 만들어두면 불필요하게 `SqlService` 코드를 통해 특정 포맷으로 변환한 SQL정보를 주고받을 필요 없이 `SqlReader`가 직접 `SqlRegistry`에 SQL 정보를 등록할 수 있다.
- `SqlReader`는 내부에 갖고 있는 SQL 정보를 형식을 갖춰서 돌려주는 대신, 협력관계에 있는 의존 오브젝트인 `SqlRegistry`에게 필요에 따라 등록을 요청할 때만 활용하면 된다.

![](picture-7-4.jpeg)

### `SqlRegistry` 인터페이스

![](list-7-30.jpeg)

- SQL을 등록하고 검색하는 두 가지 기능을 메서드로 정의하고 있다.

### `SqlReader` 인터페이스

![](list-7-31.jpeg)

- 두 개의 책임에 대한 인터페이스를 모두 정의했다.
- 이제 `SqlService`가 각각의 구현 오브젝트를 DI 받도록 하면 된다.

## 7.2.5 자기참조 빈으로 시작하기

### 다중 인터페이스 구현과 간접 참조

- `SqlService`의 구현 클래스는 이제 `SqlReader`와 `SqlRegistry` 두 개의 프로퍼티를 DI받을 수 있는 구조로 만들어야 한다.

![](picture-7-5.jpeg)

- 그런데 자바는 한 개 이상의 인터페이스를 구현할 수 있다.
- 이를 이용해 `XmlSqlService`를 구현해보자.

![](picture-7-6.jpeg)

### 인터페이스를 이용한 분리

- 일단 `XmlSqlService`는 `SqlService`만을 구현한 독립적인 클래스라고 생각하자.

![](list-7-32.jpeg)

- 그 다음, `SqlRegistry`를 구현하도록 만들자.

![](list-7-33.jpeg)

- 마지막으로 `SqlReader`를 구현하도록 만들자.

![](list-7-34.jpeg)

- 마지막으로 `SqlService` 인터페이스 구현을 마무리하자.
- `@PostConstruct`가 달린 빈 초기화 메서드와 `SqlService` 인터페이스에 선언된 메서드인 `getFinder()`를 `sqlReader`와 `sqlRegistry`를 이용하도록 변경한다.

![](list-7-35.jpeg)

### 자기참조 빈 설정

- `XmlSqlService`는 비록 3가지의 인터페이스를 구현하고 있지만, 상황에 맞은 인터페이스를 통해 사용되어야 한다.
    - SQL을 읽을 때에는 `SqlReader` 인터페이스를 통해서
    - SQL을 찾을 때에는 `SqlRegistry` 인터페이스를 통해서
- 이제 빈 설정을 통해 실제 DI가 일어나도록 해야 한다.
- 클래스는 하나뿐이고 빈도 하나만 등록할 것이지만, 마치 세 개의 빈이 등록된 것처럼 `SqlService` 빈이 `SqlRegistry`와 `SqlReader`를 주입받도록 만들어야 한다.

![](list-7-36.jpeg)

- 자기참조빈은 잘 사용하는 편은 아니다.
- 책임과 관심사가 복잡하게 얽혀 있어서 확장이 힘들고 변경에 취약한 구조의 클래스를 유연한 구조로 만들려고 할 때 처음 시도해볼 수 있는 방법이다.

## 7.2.6 디폴트 의존관계

- 이제 확장 가능한 인터페이스를 정의하고 인터페이스에 따라 메서드를 구분해서 DI가 가능하도록 코드를 재구성하는 데 성공했다.
- 다음은 이를 완전히 분리해두고 DI로 조합해서 사용하게 만드는 단계다.

### 확장 가능한 기반 클래스

- `SqlRegistry`와 `SqlReader`를 이용하는 가장 간단한 `SqlService` 구현 클래스를 만들어보자.
- 앞에서 자기참조가 가능한 빈으로 만들었던 `XmlSqlService` 코드에서 의존 인터페이스와 그 구현 코드를 제거하기만 하면 된다.

![](list-7-37.jpeg)

- `BaseSqlService`를 `sqlService` 빈으로 등록하고 `SqlReader`와 `SqlRegistry`를 구현한 클래스 역시 빈으로 등록해서 DI 해주면 된다.
- DI를 적용했으니 언제든지 `BaseSqlService`의 코드에는 영향을 주지 않은 채로 `SqlReader`와 `SqlRegistry`의 구현 클래스는 자유롭게 변경해서 기능을 확장할 수 있다.

![](list-7-38.jpeg)
![](list-7-39.jpeg)

- 클래스를 분리했으니 각각의 빈 설정도 필요하다.

![](list-7-40.jpeg)

### 디폴트 의존관계를 갖는 빈 만들기

- `BaseSqlService`는 `sqlReader`와 `sqlRegistry` 프로퍼티의 DI를 통해 의존관계를 자유롭게 변경해가면서 기능을 확장할 수 있다.
- 유연성을 보장하려면 이런 구조가 꼭 필요하지만, 반대로 적어도 3개의 빈을 등록해줘야 한다는 점이 귀찮게 느껴지기도 한다.
- 이렇게 확장을 고려해서 기능을 분리하고, 인터페이스와 전략 패턴을 도입하고, DI를 적용한다면 늘어난 클래스와 인터페이스 구현과 의존관계 설정에 대한 부담은 감수해야 한다.
- 설령 한동안은 JAXB를 사용하는 `SqlReader`와 `HashMap`으로 저장해두는 `SqlRegistry`를 사용할 것이 분명하다고 해도 말이다.
- 특정 의존 오브젝트가 대부분의 환경에서 거의 디폴트라고 해도 좋을 만큼 기본적으로 사용될 가능성이 있다면, 디폴트 의존관계를 갖는 빈을 만드는 것을 고려해볼 필요가 있다.
- 디폴트 의존관계란 외부에서 DI 받지 않는 경우 기본적으로 자동 적용되는 의존관계를 말한다.

![](list-7-41-1.jpeg)
![](list-7-41-2.jpeg)
![](list-7-42.jpeg)

- 하지만 이 코드는 동작하지 않는데, `JaxbXmlSqlReader`의 `sqlmapFIle` 프로퍼티가 비어있기 때문이다.
- `JaxbXmlSqlReader`를 독립적인 빈으로 설정했을 떄와 달리 디폴트 의존 오브젝트로 직접 넣어줄 때는 프로퍼티를 외부에서 직접 지정할 수 없다는 점이 문제다.
- 빈으로 등록되는 것은 `DefaultSqlService` 뿐이다.
- 이 문제를 해결할 수 있는 방법이 몇 가지 있다.
    1. `sqlmapFile`을 `DefaultSqlService`의 프로퍼티로 정의하는 방법이다.
        - 일단 `DefaultSqlService`가 `sqlmapFile`을 받아서 내부적으로 `JaxbXmlSqlReader`를 만들면서 다시 프로퍼티로 넣어주는 것이다.
        - 이 방법은 나쁘지 않지만, 단지 디폴트 오브젝트에 불과한 `JaxbXmlSqlReader`를 위해 빈의 설정으로 추가하는 것은 적절하지 못하다.
        - `JaxbXmlSqlReader`는 `SqlService`에 꼭 사용되는 오브젝트가 아니기 때문이다.
    2. `JaxbXmlSqlReader`가 디폴트 값으로 `sqlmapFile`을 갖도록 하는 것이다.

![](list-7-43.jpeg)
![](list-7-44.jpeg)

- 그런데 디폴트 의존 오브젝트를 사용하는 방법에는 단점이 한 가지 있다.
- 설정을 통해 다른 구현 오브젝트를 사용하게 해도 `DefaultSqlService`는 생성자에서일단 디폴트 의존 오브젝트를 다 만들어버린다는 점이다.
- 이는 `@PostConstruct` 애노테이션 등을 통해 프로퍼티가 설정됐는지 확인하여 조건에 따라 초기화하는 등의 방법을 통해 해결할 수 있다.

# 7.3 서비스 추상화 적용

- `JaxbXmlSqlReader`는 좀 더 개선하고 발전시킬 부분이 있다.

1. 자바에는 JAXB 외에도 다양한 XML과 자바오브젝트를 매핑하는 기술이 있다. 필요에 따라 다른 기술로 손쉽게 바꿔서 사용할 수 있게 해야 한다.
2. XML 파일을 좀 더 다양한 소스에서 가져올 수 있게 만든다. 현재는 UserDao 클래스와 같은 classpath 안에서만 XML을 읽어올 수 있다. 이것을 임의의 classpath나 파일 시스템상의 절대위치 또는 HTTP를 통해 원격에서 가져오도록 확장할 수는 없는가 하는 점이다.

## 7.3.1 OXM 서비스 추상화

- Object XML Mapping의 줄임말이다.
- JAXB는 표준이지만, 이 외에도 여러가지 XML-자바오브젝트 매핑 기술들이 존재한다.
- 스프링은 트랜잭션 외에도 OXM 추상계층을 제공한다.

### OXM 서비스 인터페이스

- 스프링이 제공하는 OXM 추상화 서비스 인터페이스에는 자바오브젝트를 XML로 변환하는 `Marshaller`와 반대로 XML을 자바오브젝트로 변환하는 `Unmarshaller`가 있다.
- `SqlReader`는 이 중에서 `Unmarshaller`를 이용하면 된다.

![](list-7-45.jpeg)

### JAXB 구현 테스트

> 이 부분은 생략한다.
> JAXB에는 OXM의 구현체가 있고, 이를 DI 받아 사용하는 지금껏 우리가 계속 해왔던 그 방식이다.

### Castor 구현 테스트

> 마찬가지로 OXM의 구현체가 있는 Castor를 사용하는 예제이므로 생략한다.

## 7.3.2 OXM 서비스 추상화 적용

- 이제 스프링의 OXM 추상화 기능을 이용하는 `SqlService`를 만들어보자.
- 이름은 `OxmSqlService`라고 하고 `SqlRegistry`는 DI 받을 수 있게 만들지만 `SqlReader`는 스프링의 OXM 언마샬러를 이용하도록 `OxmSqlService` 내에 고정시켜야 한다.
- SQL을 읽는 방법을 OXM으로 제한해서 사용성을 극대화하는 게 목적이다.
- SQL을 가져오는 방법이 스프링의 OXM 추상화 방식으로 고정된다면 `OxmSqlService` 클래스 내에 OXM 코드를 직접 넣어도 될까?
- OXM 기술에 의존적이라고 해서 꼭 코드를 직접 갖고 있을 필요는 없다.
- 이미 `SqlReader`와 `SqlRegistry`라는 두 개의 전략을 활용하는 구조를 적용해봤으므로, 이를 그대로 유지하되 `SqlReader` 구현 오브젝트에 대한 의존관계를 고정시켜버리는 방법을 생각해볼 수 있다.
- 이왕이면 구현 클래스를 `OxmSqlService`가 내장하게 하는 것도 좋겠다.

### 멤버 클래스를 참조하는 통합 클래스

- `OxmSqlService`는 `BaseSqlService`와 유사하게 `SqlReader` 타입의 의존 오브젝트를 사용하되 이를 static 멤버 클래스로 내장하고 자신만이 사용할 수 있도록 만들어보자.
- 의존 오브젝트를 자신만이 사용하도록 독점하는 구조로 만드는 방법이다.
- 유연성은 조금 손해를 보더라도 내부적으로 낮은 결합도를 유지한 채로 응집도가 높은 구현을 만들 때 유용하게 쓸 수 있는 방법이다.

![](picture-7-7.jpeg)

- 언마셜러 빈은 스프링이 제공해주니 구현할 필요는 없다.
- `SqlRegistry`는 일단 가장 단순한 `HashMapSqlRegistry`를 디폴트 의존 오브젝트로 등록해둔다.
- 단순한 오브젝트이므로 디폴트로 만들어두고 필요하면 프로퍼티로 DI 해서 바꿔서 사영하면 된다.
- `OxmSqlService`와 `OxmSqlReader`는 구조적으로는 강하게 결합되어 있지만 논리적으로 명확하게 분리되는 구조다.
- 자바의 static 멤버 클래스는 이런 용도로 쓰기에 적합하다.

![](list-7-50.jpeg)

- 이렇게 두 개의 클래스를 강하게 결합하고 더 이상의 확장이나 변경을 제한해두는 이유는 무엇일까?
- 그것은 OXM을 이용하는 서비스 구조로 최적화하기 위해서다.
- 하나의 클래스로 만들어두기 떄문에 빈의 등록과 설정은 단순해지고 쉽게 사용할 수 있다.

![](picture-7-8.jpeg)

- `OxmSqlReader`는 외부에 노출되지 않기 때문에 `OxmSqlService`에 의해서만 만들어지고, 스스로 빈으로 등록될 수 없다.
- 따라서 자신이 DI를 통해 제공받아야 하는 프로퍼티가 있다면 이를 `OxmSqlService`의 공개된 프로퍼티를 통해 간접적으로 DI 받아야 한다.

![](list-7-51.jpeg)
![](list-7-52-1.jpeg)
![](list-7-52-2.jpeg)

- 이제 OXM을 적용했음에도 빈 설정은 여전히 단순하게 유지할 수 있게 됐다.
- 어차피 OXM 기술을 지정하고 그에 따른 설정이 필요한 언마샬러 빈은 따로 필요한 것이고, 그 외의 `SqlService`와 OXM 언마샬러를 사용하는 `SqlReader` 그리고 `SqlRegistry`는 하나의 빈을 등록하는 것으로 충분하기 때문이다.
- `SqlRegistry`는 필요에 따라 다른 구현으로 교체할 수도 있다.

### 위임을 이용한 `BaseSqlService`의 재사용

- `OxmSqlService`는 `SqlReader`를 static 멤버 클래스로 고정시켜서 OXM에 특화된 형태로 재구성했기 때문에 설정은 간결해지고 의도되지 않은 방식으로 확장될 위험이 없다.
- 그런데 한 가지 좀 꺼림칙한 부분이 있다.
- `loadSql()`과 `getSql()`이라는 `SqlService`의 핵심 메서드 구현 코드가 `BaseSqlService`와 동일하다는 점이다.
- 프로퍼티 설정을 통한 초기화 작업을 제외하면 두 가지 작업의 코드는 `BaseSqlService`와 `OxmSqlService` 양쪽에 중복된다.
- 워낙 간단한 내용이니 이 정도의 중복은 무시할 수도 있을 것이다.
    - 만약 무시하지 않고 중복을 제거하고자 한다면, 새로운 슈퍼클래스를 만들고 공통된 코드를 추출하는 방식 등으로 복잡한 계층구조로 만들어져 부담스럽다.
    - 그래서 이런 경우에는 그냥 간단한 코드의 중복쯤은 허용해도 문제 없어 보인다.
- 그런데 `loadSql()`과 `getSql()` 코드가 복잡하며 변경도 자주 일어난다면 어떻게 할 것인가?
- 수정이 발생할 때마다 양쪽을 모두 변경해야 하니 부담스럽고 실수로 인한 버그가 생길 확률이 높아진다.
- 이런 경우에는 미래를 대비한다는 의미로 중복된 코드를 제거할 수도 있다.
- 코드의 중복은 위임 구조를 이용해 제거할 수도 있다.
    - 객체 합성
- `OxmSqlService`는 일종의 설정과 기본 구성을 변경해주기 위한 어댑터 같은 개념으로, `BaseSqlService`의 앞에 두는 설계가 가능하다.
- `OxmSqlService`의 외형적인 틀은 유지한 채로 `SqlService`의 기능 구현은 `BaseSqlService`로 위임하는 것이다.

![](picture-7-9.jpeg)
![](list-7-54.jpeg)

## 7.3.3 리소스 추상화

- 지금까지 만든 `OxmSqlReader`나 `XmlSqlReader`에는 공통적인 문제점이 있다.
- SQL 매핑정보가 담긴 XML 파일 이름을 프로퍼티로 외부에서 지정할 수는 있지만 `UserDao` 클래스와 같은 classpath에 존재하는 파일로 제한된다는 점이다.
- 리소스의 위치가 파일시스템이 아닌 http, ftp로 접근해야 한다면?
- 안타깝게도 자바에는 이렇게 다양한 위치에 존재하는 리소스에 대한 단일화된 접근 인터페이스를 제공해주는 클래스가 없다.
- 그나마 URL을 이용해 웹상의 리소스에 접근할 때 사용할 수 있는 `java.net.URL` 클래스가 있을 뿐이다.

### 리소스

- 스프링은 자바에 존재하는 일관성 없는 리소스 접근 API를 추상화해서 `Resource`라는 추상화 인터페이스를 정의했다.
- 애플리케이션 컨텍스트가 사용할 설정정보 파일을 지정하는 것부터 시작해서 스프링의 거의 모든 API는 외부의 리소스 정보가 필요할 때는 항상 이 `Resource` 추상화를 이용한다.

### 리소스 로더

- 스프링에는 URL 클래스와 유사하게 접두어를 이용해 `Resource` 오브젝트를 선언하는 방법이 있다.
- 문자열 안에 리소스의 종류와 리소스의 위치를 함께 표현하게 해주는 것이다.
- 그리고 이렇게 문자열로 정의된 리소스를 실제 `Resource` 타입 오브젝트로 변환해주는 `ResourceLoader`를 제공한다.
- `ResourceLoader`는 다양한 접두어(file: classpath: http:)와 `ResourceLoader`의 구현 방식에 따라 `Resource`를 가져오는 방식이 달라진다.
- `ResourceLoader`의 대표적인 예는 바로 스프링의 애플리케이션 컨텍스트다.
- `ApplicationContext`는 `ResourceLoader` 인터페이스를 상속하고 있다.

### `Resource`를 이용해 XML 파일 가져오기

![](list-7-57-1.jpeg)![](list-7-57-2.jpeg)

- `Resource`는 실제 리소스는 아니고 단지 추상화된 핸들러임을 명심해야 한다.
- 실제 리소스의 위치를 명시만 하면, 해당 리소스를 읽어 가져올 것이다.

![](list-7-58.jpeg)![](list-7-59.jpeg)

# 7.4 인터페이스 상속을 통한 안전한 기능확장

- 원치적으로 권장되진 않지만 때로는 서버가 운영중인 상태에서 서버를 재시작하지 않고 긴급하게 애플리케이션이 사용 중인 SQL을 변경해야 할 수도 있다.
- 지금까지 만든 `SqlService` 구현 클래스들은 초기에 리소스로부터 SQL 정보를 읽어오면 이를 메모리에 두고 그대로 사용한다.
- 따라서 매핑정보가 변경되도 서버를 재시작하지 않는 한 반영되지 않는다.
- 애플리케이션을 새로 시작하지 않고 특정 SQL의 내용만을 변경하고 싶다면 어떻게 해야 할지 생각해보자.
- SQL 정보의 실시간 변경이라는 기능을 추가하려면 지금까지 만들고 다듬어왔던 `SqlService` 구현 클래스는 물론이고 핵심 인터페이스까지 뜯어고쳐야 할지도 모르겠다.
- 기능의 변경 또는 추가에 대응하는 방법은 상황이나 조건에 따라 달라질 수 있다.
- 스프링답게 접근하는 방법이 무엇인지를 살펴보자.

## 7.4.1 DI와 기능의 확장

- DI의 가치를 제대로 얻으려면 DI에 적합한 오브젝트 설계가 필요하다.

### DI를 의식하는 설계

- 초기부터 SqlService의 내부 기능을 적절한 책임과 역할에 따라 분리하고, 인터페이스를 정의해 느슨하게 연결해주고, DI를 통해 유연하게 의존관계를 지정하도록 설계해뒀기 때문에 그 뒤의 작업은 매우 쉬워졌다.
- 오브젝트들이 서로의 세부적인 구현에 얽매이지 않고 유연한 방식으로 의존관계를 맺으며 독립적으로 발전할 수 있게 해주는 DI 덕분이다.
- 결국 유연하고 확장 가능한 좋은 오브젝트 설계와 DI 프로그래밍 모델은 서로 상승작용을 한다.
- 스프링에 DI 기술을 적용하는 것은 쉽지만, 가치를 제대로 활용하는 것은 쉽지 않다.
- DI에 필요한 유연하고 확장성이 뛰어난 오브젝트 설계를 하려면 많은 고민과 학습, 훈련, 경험이 필요하다.
- 확장은 항상 미래에 일어나는 일이다.
- 지금 당장 기능이 동작하는 데 아무런 문제가 없으면 된다고 생각하면 오늘을 위한 설계밖에 나오지 않는다.
- DI는 확장을 위해 필요한 것이므로 항상 미래에 일어날 변화를 예상하고 고민해야 적합한 설계가 가능해진다.
- DI란 결국 미래를 프로그래밍하는 것이다.

### DI와 인터페이스 프로그래밍

- DI를 적용할 때는 가능한 한 인터페이스를 사용하게 해야 한다.
- 물론 인터페이스를 사용하지 않고도 DI는 가능하다.
- 하지만 DI를 DI답게 만들려면 두 개의 오브젝트가 인터페이스를 통해 느슨하게 연결돼야 한다.
- 인터페이스를 사용하는 첫 번쨰 이유는 다형성을 얻기 위해서다.
- 하나의 인터페이스를 통해 여러 개의 구현을 바꿔가면서 사용할 수 있게 하는 것이 DI가 추구하는 첫 번째 목적이다.
- 하지만 단지 DI의 목적이 다형성을 편리하게 적용하는 것 때문이라면 제약이 많고 불편한 점이 있다고 해도 클래스를 사용할 수도 있다.
- 그럼에도 인터페이스를 사용해야 하는 이유가 또 있다면 그것은 인터페이스 분리 원칙을 통해 클라이언트와 의존 오브젝트 사이의 관계를 명확하게 해줄 수 있기 때문이다.
- 인터페이스는 하나의 오브젝트가 여러 개를 구현할 수 있으므로, 하나의 오브젝트를 바라보는 창이 여러 가지일 수도 있다는 의미다.
- 오브젝트가 그 자체로 충분히 응집도가 높은 작은 단위로 설계됐더라도, 목적과 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 이를 적절하게 분리해줄 필요가 있다.
- 이를 객체지향 설계 원칙에서는 인터페이스 분리 원칙이라고 부른다.
- 분명한 이유가 있어서 인터페이스를 사용하지 않는 경우가 없지는 않겠지만, 단지 인터페이스를 추가하기가 귀찮아서 약간의 게으름을 부리고자 인터페이스를 생략한다면 이후의 개발, 디버깅, 테스트, 기능의 추가, 변화 등에서 적지 않은 부담을 안게 될 것이다.

## 7.4.2 인터페이스 상속

- 하나의 오브젝트가 구현하는 인터페이스를 여러 개 만들어서 구분하는 이유 중의 하나는 오브젝트의 기능이 발전하는 과정에서 다른 종류의 클라이언트가 등장하기 때문이다.
- 때로는 인터페이스를 여러 개 만드는 대신 기존 인터페이스를 상속을 통해 확장하는 방법도 사용된다.
- 인터페이스 분리 원칙이 주는 장점은 모든 클라이언트가 자신의 관심에 따른 접근 방식을 불필요한 간섭 없이 유지할 수 있다는 점이다.
- 그래서 기존 클라이언트에 영향을 주지 않은 채로 오브젝트의 기능을 확장하거나 수정할 수 있다.

![](picture-7-10.jpeg)
![](list-7-62.jpeg)

- 기존에 있던 `BaseSqlService`가 꼭 새로운 `UpdatableSqlRegistry` 인터페이스를 사용할 필요는 없다.
- 다만, 업데이트 작업이 필요한 새로운 클라이언트가 `UpdatableSqlRegistry` 인터페이스를 통해 `SqlRegistry` 오브젝트에 접근하도록 만들면 된다.

![](list-7-64.jpeg)

- 코드 상에서는 각각의 `SqlService`들은 `SqlRegistry`와 `UpdatableSqlRegistry` 인터페이스로 각각 관심과 필요에 따라서 인터페이스를 통해 접근한다.
- 런타임에는 둘이 동일한 인스턴스라고 해도, 코드상에서는 서로가 필요로 하는 책임만을 가진 인터페이스로 접근하고 있는 것이다.
- 이렇게 인터페이스를 추가하거나 상속을 통해 확장하는 방식을 잘 활용하면 이미 기존의 인터페이스를 사용하는 클라이언트가 있는 경우에도 유연한 확장이 가능해진다.
- 잘 적용된 DI는 결국 잘 설계된 오브젝트 의존관계에 달려 있다.
- 인터페이스를 적절하게 분리하고 확장하는 방법을 통해 오브젝트 사이의 의존관계를 명확하게 해주고, 기존 의존관계에 영향을 주지 않으면서 유연한 확장성을 얻는 방법이 무엇인지 항상 고민해야 한다.
- 다시 말하지만, DI와 객체지향 설계는 서로 밀접한 관계를 맺고 있다.

# 7.5 DI를 이용해 다양한 구현 방법 적용하기

- 운영 중인 시스템에서 사용하는 정보를 실시간으로 변경하는 작업을 만들 때 가장 먼저 고려해야 할 사항은 동시성 문제다.
- 한 번 초기화하고 그 뒤에는 읽기전용으로 동작하는 기존의 `SqlRegistry`의 방식에서는 여러 스레드가 함께 접근할 때 발생하는 동시성 문제가 발생할 일이 없다.
- 하지만 수정은 다르다. 동시 접속자가 많은 대형 시스템의 DAO라면 수시로 접근하는 SQL 레지스트리 정보를 잘못 수정하다가 어느 순간 깨진 SQL이 나타날 수도 있다.
- 복잡한 동시성 문제는 이 책의 주제범위를 벗어나므로, 간단한 방식으로 어느 정도 안전한 업데이트가 가능한 SQL 레지스트리를 구현해보자.

### 7.5.1 `ConcurrentHashMap`을 이용한 수정 가능 SQL 레지스트리

- `HashMap`은 thread-safe 하지 않으므로, `Collections.synchronizeMap()` 등을 이용해 외부에서 동기화해줘야 한다.
- 하지만 이렇게 `HashMap`에 대한 전 작업을 동기화하면 `SqlService`처럼 DAO의 요청이 많은 고성능 서비스에서는 성능에 문제가 생긴다.
- 그래서 동기화된 해시 데이터 조작에 최적화되도록 만들어진 `ConcurrentHashMap`을 사용하는 방법이 일반적으로 권장된다.
- `ConcurrentHashMap`은 데이터 조작시 전체 데이터에 대해 락을 걸지 않고 조회는 락을 아예 사용하지 않는다.
- 그래서 어느 정도 안전하면서 성능이 보장되는 동기화된 `HashMap`으로 이용하기에 적당하다.

### 수정 가능 SQL 레지스트리 구현

![](list-7-66.jpeg)

- 수정 기능을 가진 SQL 레지스트리를 적용하기 전에 먼저 테스트를 이용해 모든 수정 기능이 완벽하게 동작하는지 검증하는 것을 잊지 말자.
- `OxmSqlService`는 `SqlRegistry` 프로퍼티를 지정하지 않으면 디폴트로 설정된 단순한 `HashMapSqlRegistry`를 사용하게 되어 있다.
- 그래서 설정을 통해 디폴트 대신 새로 만든 `ConcurrentHashMapSqlRegistry` 빈을 사용하도록 빈 설정을 수정하자.

![](list-7-67.jpeg)

### 7.5.2 내장형 데이터베이스를 이용한 SQL 레지스트리 만들기

- 이번엔 ConcurrentHashMap 대신 내장형 DB를 이용해 SQL을 저장하고 수정하도록 만들어보겠다.
- ConcurrentHashMap이 멀티스레드 환경에서 최소한의 동시성을 보장해주고 성능도 그리 나쁜 편은 아니지만, 저장되는 데이터의 양이 많아지고 잦은 조회와 변경이 일어나는 환경이라면 한계가 있다.
- 내장형 DB는 애플리케이션에 내장돼서 애플리케이션과 함께 시작되고 종료되는 DB를 말한다.
- 데이터는 메모리에 저장되기 때문에 IO로 인해 발생하는 부하가 적어서 성능이 뛰어나다.
- 동시에 Map과 같은 컬렉션이나 오브젝트를 이용해 메모리에 데이터를 저장해두는 방법에 비해 매우 효과적이고 안정적인 방법으로 등록, 수정, 검색이 가능하다.
- 최적화된 락킹, 격리수준, 트랜잭션을 적용할 수도 있다.

### 스프링의 내장형 DB 지원 기능

- 자바에서 많이 사용되는 내장형 데이터베이스는 Derby, HSQL, H2를 꼽을 수 있다.
- 모두 JDBC 드라이버를 제공한다.
- 스프링은 내장형 DB를 손쉽게 이용할 수 있도록 내장형 DB 지원 기능을 제공하고 있다.
- 일종의 내장형 DB를 위한 서비스 추상화 기능이다.
- 스프링은 내장형 DB를 초기화하는 작업을 지원하는 편리한 내장형 DB 빌더를 제공한다.
- 내장형 DB 인스턴스는 보통 고유한 JDBC 접속 URL을 통해 연결을 시도하면 JDBC 드라이버 내에서 이를 생성해준다.
- 스프링의 내장형 DB 빌더에는 대표적인 세 가지 내장형 DB를 사용할 때 필요한 URL과 드라이버 등을 초기화해주는 기능이 있다.

### 내장형 DB 빌더 학습 테스트

> 생략

### 내장형 DB를 이용한 `SqlRegistry` 만들기

- `EmbeddedDatabaseBuilder` 오브젝트는 한 번 초기화를 거쳐서 내장형 DB를 기동하고 이에 접근할 수 있는 `EmbeddedDatabase`를 만들어 주면 그 이후로는 사용할 일은 없다.
- 따라서 `EmbeddedDatabaseBuilder`를 활용해서 `EmbeddedDatabase` 타입의 오브젝트를 생성해주는 팩토리 빈을 만들어야 한다.
- 다행히 스프링에는 팩토리 빈을 만드는 번거로운 작업을 대신해주는 전용 태그가 있다.
- 내장형 DB와 관련된 빈을 설정하고 등록해주는 기능이 있는 태그들은 jdbc 스키마에 정의되어 있다.

![](list-7-71.jpeg)
![](list-7-72.jpeg)

- `EmbeddedDatabase` 은 `DataSource`를 extends 하므로 `DataSource`를 DI 받도록 했다.
    - 왜 `EmbeddedDatabase`가 아니라 `DataSource`를 받도록 했을까?
    - 이는 인터페이스 분리 원칙을 지키기 위해서다.
    - 즉, 클라이언트는 자신이 필요로 하는 기능을 가진 인터페이스를 통해 의존 오브젝트를 DI 해야 한다.

### XML 설정을 통한 내장형 DB의 생성과 적용

> XML 설정을 통해 단순히 설정하는 과정이므로, 생략

## 7.5.3 트랜잭션 적용

- `EmbeddedSqlRegistry`는 내장형 DB를 사용하기 때문에 조회가 빈번하게 일어나는 중에도 데이터가 깨지는 일 없이 안전하게 SQL을 수정하도록 보장해준다.
- 하나의 SQL을 수정할 때는 문제가 없다.
- 하지만 하나 이상의 SQL을 맵으로 전달받아 한 번에 수정해야 하는 경우 자칫 심각한 문제가 발생할 수 있다.

![](list-7-72-problem.jpeg)

- `updateSql()` 메서드는 한 번에 한 개의 SQL을 수정해주는 같은 이름의 `updateSql()` 메서드를 맵 안에 있는 SQL의 갯수만큼 반복해서 호출하도록 되어 있다.
- 그런데 여러 개의 SQL을 변경하는 작업을 진행하는 중에 존재하지 않는 키가 발견되면 어떻게 될까?
- 이런 경우에는 예외가 발생하도록 되어 있으니 작업이 중단될 것이다.
- 문제는 `updateSql()` 메서드는 단순히 `SimpleJdbcTemplate`을 사용해 SQL을 실행하고 있으므로 트랜잭션이 적용되어 있지 않다는 점이다.
- 운영중인 시스템에서 한 번에 한 개 이상의 SQL이 변경되어야 한다면, 이 작업은 반드시 하나의 트랜잭션 안에서 일어나야 한다.
    - 일부는 변경되고 일부는 변경되지 않은채 동작한다면 문제가 발생하기 때문이다.
- `HashMap`과 같은 컬랙션은 트랜잭션 개념을 적용하기가 매우 힘들지만, 내장형 DB를 사용하는 경우에는 트랜잭션 적용이 상대적으로 쉽다.
    - 이미 DB 자체가 트랜잭션을 지원하기 때문이다.
- 조금 번거로운 설정이 뒤따름에도 내장형 DB를 도입한 이유는 바로 이런 트랜잭션과 같은 안전한 수정 작업이 가능하기 때문이다.

### 코드를 이용한 트랜잭션 적용

- `PlatformTransactionManager`를 직접 사용해서 트랜잭션 처리 코드를 만들어도 되지만 그보다는 간결하게 트랜잭션 적용 코드에 템플릿/콜백 패턴을 적용한 `TransactionTemplate`을 쓰는 편이 낫다.
- `EmbeddedDbSqlRegistry`가 `DataSource`를 DI 받아서 트랜잭션 매니저와 템플릿을 만들게 한다.
- 일반적으로는 트랜잭션 매니저를 싱글톤 빈으로 등록해서 사용하는데, 그 이유는 여러 개의 AOP를 통해 만들어지는 트랜잭션 프록시가 같은 트랜잭션 매니저를 공유해야 하기 때문이다.
- 반면에 `EmbeddedDbSqlRegistry`가 사용할 내장형 DB에 대한 트랜잭션 매니저는 공유할 필요가 없다.
- 따라서 번거롭게 빈으로 등록하는 대신 `EmbeddedDbSqlRegistry` 내부에서 직접 만들어 사용하는 게 낫다.

![](list-7-81.jpeg)

# 7.6 스프링 3.1의 DI

### 자바 언어의 변화와 스프링

- 스프링이 제공하는 모든 기술의 기초가 되는 DI의 원리는 변하지 않았지만 DI가 적용된 코드를 작성할 때 사용하는 핵심 도구인 자바 언어에는 그간 적지 않은 변화가 있었다.
- 이런 변화들이 DI 프레임워크로서 스프링의 사용 방식에도 여러 가지 영향을 줬다.
- 대표적인 두 가지 변화를 살펴보자.

#### 1. 애노테이션의 메타정보 활용

- 자바 코드의 메타정보를 이용한 프로그래밍 방식
- 자바 5와 JavaEE5가 등장한 시점부터, 메타프로그래밍 방식이 널리 사용되었다.
- 메타프로그래밍의 절정은 자바 5에서 등장한 애노테이션일 것이다.
- 애노테이션은 옵션에 따라 컴파일된 클래스에 존재하거나 애플리케이션이 동작할 때 메모리에 로딩되기도 하지만 자바 코드가 실행되는 데 직접 참여하지 못한다.
- 그럼에도 애노테이션을 이용하는 표준 기술과 프레임워크는 빠르게 증가했다.
- 이유가 무엇일까?
- 애노테이션은 애플리케이션의 핵심 로직을 담은 자바 코드와 이를 지원하는 IoC 방식의 프레임워크, 그리고 프레임워크가 참조하는 메타정보라는 세 가지로 구성하는 방식에 잘 어울리기 때문일 것이다.
- 런타임 의존관계 정보를 담고 있는 DaoFactory를 생각해보자.
- 처음에는 평범한 자바 코드로 작성됐다.
- 그런데 UsrDao 한 가지가 아니라 애플리케이션을 구성하는 많은 오브젝트의 관계를 IoC/DI를 이용해서 프레임워크와 메타정보를 활용하는 방식으로 작성하도록 발전시키려면 DaoFactory와 같은 단순한 자바 코드로 만들어진 관계 설정 책임을 담은 코드는 불편하다.
- 그래서 DaoFactory의 내용을 XML로 전환해서 좀 더 간결한 형태로 전환했다.
- 어차피 DaoFactory는 애플리케이션의 로직을 담은 코드에서 사용될 일이 없기 때문에 형태가 어떻든지 상관없다.
- XML은 DaoFactory같은 자바 코드를 이용할 때보다 프레임워크가 할 일이 좀 더 많아지긴 하지만, 작성하기 편하고 빌드 과정이 필요 없으며, AOP를 위해 빈 생성과 관계 설정을 재구성하는 경우를 고려하면 자바 코드보다 유리했기 때문에 스프링 초창기부터 XML이 프레임워크가 사용하는 오브젝트 관계 설정용 DI 메타정보로 적극 활용돼왔다.
- 하지만 애노테이션이 등장하면서 상황이 달라졌다.

```java
@Special
class MyClass {
	// ...
}
```

- `@Special`이라는 간단한 애노테이션 하나를 클래스 선언 위에 넣었을 뿐이다.
- 그런데 이렇게 하는 것만으로도 여러 가지 정보를 추가로 얻을 수 있다.
- 애노테이션이 위치한 클래스의 메타정보들을 쉽게 얻을 수 있다.
- 반면에 동일한 정보를 XML로 표현하려면 모든 내용을 명시적으로 나타내야 한다.

```xml
<x:special target="type" class="com.mycompany.myproject.MyClass" />
```

- 애노테이션 하나를 자바 코드에 넣는 것에 비해 작성할 정보의 양이 많다.
- 리팩토링에서도 많은 차이점이 드러난다.
- MyClass의 클래스 이름을 변경하면, XML의 모든 설정 정보를 변경해야 한다.
- 하지만 애노테이션은 그럴 필요가 없다.
- 물론 애노테이션에도 단점이 있다.
- XML은 어느 환경에서나 손쉽게 편집이 가능하고 빌드과정이 필요없지만, 애노테이션은 자바 코드에 존재하므로 변경할 때마다 새로 컴파일해줘야 한다.
- 자바 개발의 흐름은 점차 XML 같은 텍스트 형태의 메타정보 활용을 자바 코드에 내장된 애노테이션으로 대체하는 쪽으로 가고 있다.

#### 2. 정책과 관례를 이용한 프로그래밍

- 애노테이션 같은 메타정보를 활용하는 프로그래밍 방식은 코드를 이용해 명시적으로 동작 내용을 기술하는 대신 코드 없이도 미리 약속한 규칙 또는 관례를 따라서 프로그램이 동작하도록 만드는 프로그래밍 스타일을 적극적으로 포용하게 만들어왔다.
    - XML의 bean 설정 등
- 반면에 프로그래밍 언어나 API 사용법 외에 미리 정의된 많은 규칙과 관례를 기억해야 하고, 메타정보를 보고 프로그램이 어떻게 동작할지 이해해야 하는 부담을 주기도 한다.
- 익숙해지면 편하겠지만, 그때까지 적지 않은 학습 비용이 들고, 자칫 잘못 이해하고 있을 경우 찾기 힘든 버그를 만들어내기도 한다.
- 그럼에도 코드로 직접 모든 내용을 작성하는 것보다 간결하고 빠른 개발이 가능하기 때문에 이런 스타일의 프로그래밍 방식은 지속적으로 인기를 끌고 있다.
    - `@Transacitonal` 등
- 애플리케이션이 동작하는 방식과 기능을 코드에 직접 담는 것이 좋을 수도 있고, XML과 같은 메타정보로 작성해두고 프레임워크에 의해 동작하도록 만드는 편이 나을 수도 있다.
- 어쨌든 스프링은 점차 애노테이션으로 메타정보를 작성하고, 미리 정해진 정책과 관례를 활용해서 간결한 코드에 많은 내용을 담을 수 있는 방식을 적극 도입하고 있다.
- 이 절에서는 DAO와 서비스 기능의 예제 코드를 스프링 3.1의 최신(?) DI 스타일로 바꾸는 과정을 보여줄 것이다.

## 7.6.1 자바 코드를 이용한 빈 설정

- 첫 번째 작업은 XML을 없애는 것이다.
- 이는 `@Configuration` 애노테이션으로 목적을 달성할 수 있다.

### 테스트 컨텍스트의 변경

```java
@Configuration
class TestApplicationContext {
	// ...
}

@SpringBootTest
@ContextConfiguration(classes = [TestApplicationContext::class])
class UserDaoTest {
	// ...
}

@Configuration
@ImportResource("/test-applicationContext.xml")
class TestApplicationContext {
	// ...
}
```

-  자바 클래스로 만들어진 DI 설정정보에 XML의 설정정보를 가져오게도 만들 수 있다.

### `<context:annotation-config />` 제거

- 이 태그는 `@PostConstuct`를 붙인 메서드가 빈이 초기화된 후에 자동으로 실행되도록 한다.
- 그런데 이제는 스프링 컨테이너가 참고하는 DI 정보의 위치가 XML에서 `TestApplicationContext`로 바뀌었기 때문에 제거해도 된다.
    - 이는` @Configuration` 애노테이션이 붙은 컨테이너가 직접 `@PostConstruct` 애노테이션을 처리하는 빈 후처리기를 등록해주기 때문이다.

### `<bean>`의 전환

- `@Bean` 애노테이션을 사용하면 된다.
- `@Bean` 메서드의 이름이 빈의 id가 된다.
- `@Bean` 메서드가 리턴하는 오브젝트가 빈으로 사용된다.

![](list-7-88.jpeg)
![](list-7-89.jpeg)

> 이제는 XML설정이 아닌 자바코드 설정이 기본으로 사용되므로, 그 외 XML -> 자바코드 전환 내용은 생략한다.

### 전용 태그 전환

- `<tx:annotation-driven />`은 `@EnableTransactionManagement` 애노테이션으로 대체 가능하다.

## 7.6.2 빈 스캐닝과 자동와이어링

### `@Autowired`를 이용한 자동와이어링

- 조건에 맞는 빈을 찾아 자동으로 수정자 메서드나 필드에 넣어준다.
- 컨테이너가 이름이나 타입을 기준으로 주입될 빈을 찾아주기 때문에 빈의 프로퍼티 설정을 직접해주는 자바 코드나 XML의 양을 대폭 줄일 수 있다.
- 주입할 빈이 모호하여 어려운 경우도 있는데, 이럴 땐 직접 프로퍼티에 주입할 대상을 지정하는 방법을 병행하면 된다.

![](list-7-100.jpeg)
![](list-7-101.jpeg)

- 사실 수정자, 필드주입 방법도 요즘은 잘 사용하지 않고, 생성자 방법을 사용한다.

### `@Component`를 이용한 자동 빈 등록

- 클래스에 부여되며, 빈 스캐너를 통해 자동으로 빈으로 등록된다.
    - 정확히는 `@Component` 또는 `@Component`를 메타 애노테이션으로 갖고 있는 애노테이션이 붙은 클래스가 자동 빈 등록 대상이 된다.
        - `@Repository`
        - `@Service`
        - etc...
- `@Component` 애노테이션이 달린 클래스를 자동으로 찾아서 빈을 등록해주게 하려면 빈 스캔 기능을 사용하겠다는 애노테이션 정의가 필요하다.
- 빈 자동등록이 컨테이너가 디폴트로 제공하는 기능이 아니기 때문이다.
    - 스프링 부트에서는 디폴트 값이다.

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
	// ...
}
```

- 빈의 아이디를 따로 지정하지 않으면 클래스의 첫 글자를 소문자로 바꿔서 사용한다.
- 만약 빈의 아이디를 다른 것으로 지정하고 싶다면 애노테이션의 value값을 설정해주면 된다.

```java
@Component("userDao")
```

- `@Autowired`는 타입을 기준으로 하나의 빈을 찾게 되어 있다.
- 만약 같은 타입의 빈이 두 개 이상 발견되면 이름을 기준으로 다시 최종 후보를 찾는 방식으로 동작한다.

## 7.6.3 컨텍스트 분리와 `@Import`

### 테스트용 컨텍스트 분리

- 테스트에서만 사용되는 빈들은 운영 빈 DI 정보와 분리되는 것이 좋다.
- DI 설정정보를 분리하는 방법은 간단한데, 새로 DI 설정 클래스를 추가하고 관련된 빈설정 애노테이션, 필드, 메서드를 옮기면 된다.

![](list-7-109.jpeg)

### `@Import`

- SQL 서비스의 경우, 그 자체로도 독립적인 모듈로 취급될 수 있다.
- 이는 다른 애플리케이션에서도 사용될 수 있기 때문이다.
- 따라서 따로 빈설정을 분리한다.
- 그럼에도, SQL 서비스는 항상 애플리케이션에 필요하므로 메인이 되는 `@Configuration` 클래스에 `@Import`를 이용해서 설정정보를 가져오게 하는게 좋다.

![](list-7-113.jpeg)

## 7.6.4 프로파일

- 테스트환경과 운영환경에서 각기 다른 빈 정의가 필요한 경우가 종종 있다.
    - 예를 들어, 메일 서비스 등
- 아예 테스트할 때만 필요한 빈이라면 테스트용 설정 클래스에만 넣으면 되지만, 테스트 환경과 운영환경 양쪽 모두에 필요하면서 빈의 내용이 달라져야 하는 경우, 빈 설정정보 작성이 곤란해진다.
- `@Autowired`를 이용해 자동으로 주입되는 경우 빈 아이디를 다르게 설정하는 것으로 간단히 해결할 수도 없다.
- 이 문제를 해결하려면 운영환경에서는 반드시 필요하지만 테스트 실행 중에는 배제돼야 하는 빈 설정을 별도의 설정 클래스를 만들어 따로 관리할 필요가 있다.

### `@Profile`과 `@ActiveProfiles`

- 스프링은 환경에 따라 빈 설정정보가 달라져야 하는 경우, 파일을 여러 개로 쪼개고 조합하는 등의 번거로운 방법 대신 간단히 설정정보를 구성할 수 있는 방법을 제공한다.
- 실행환경에 따라 빈 구성이 달라지는 내용을 프로파일로 정의해서 만들어두고, 실행 시점에 어떤 프로파일의 빈 설정을 사용할지 지정하는 것이다.

```java
@Configuration
@Profile("test")
public class TestAppContext {
	// ...
}
```

- 이제 두 개의 설정 클래스를 모두 메인 설정에 추가한다.

```java
@Configuration
@EnableTransactionManagement
@ComponentScan(basePackages = "springbook.user")
@Import({SqlServiceContext.class, TestAppContext.class, ProductionAppContext.class})
public class AppContext {
	// ...
}
```

- 이제 `AppContext` 하나만 남기자.

```java
@ContextConfiguration(classes = AppContext.class)
```

- 이 상태에서 활성 프로파일을 지정한다.

```java
@ActiveProfiles("test")
@ContextConfiguration(classes = AppContext.class)
public class UserServiceTest {
	// ...
}
```

### 컨테이너의 빈 등록 정보 확인

- 컨테이너가 생성한 빈에 어떤 게 있는지 확인하는 방법을 알아보자.
- 스프링 컨테이너는 `BeanFactory` 인터페이스를 구현하고 있다.
- `BeanFactory`의 구현 클래스 중에 `DefaultListableBeanFactory`가 있는데 거의 대부분의 스프링 컨테이너는 이 클래스를 이용해 빈을 등록하고 관리한다.
- 스프링은 친절하게도 `DefaultListableBeanFactory` 오브젝트를 `@Autowired`로 주입 받아서 이용하게 해준다.
- `DefaultListableBeanFactory`에는 `getBeanDefinitionNames()` 메서드가 있어서 컨테이너에 등록된 모든 빈 이름을 가져올 수 있고, 빈 이름을 이용해서 실제 빈과 빈 클래스 정보 등도 조회해볼 수 있다.

![](list-7-119.jpeg)

### 중첩 클래스를 이용한 프로파일 적용

- 파일이 많아지면 전체 구성을 살펴보기가 번거로워진다.
- 서로 의존관계를 맺고 있는 빈들이 많아진다면 어느 빈이 어디서 적용됐는지 확인하기 위해 여러 개의 클래스 파일을 열어봐야 할 것이다.
- 프로파일마다 빈 구성이나 구현 클래스에 어떤 차이가 있는지 한눈에 비교하기 불편할 수도 있다.
- 이런 경우, 프로파일들을 중첩클래스를 통해 하나의 파일로 관리할 수 있다.

![](list-7-120-1.jpeg)
![](list-7-120-2.jpeg)

- 사실 `@Configuration` 중첩 클래스는 스프링 컨테이너가 자동으로 포함해주기 때문에 `@Import`에 굳이 명시할 필요는 없다.

```java
@Import(SqlServiceContext.class)
```

## 7.6.5 프로퍼티 소스

- 적어도 DB 연결정보는 환경에 따라 다르게 설정될 수 있어야 한다.
- 또한 같은 종류의 환경이더라도 필요에 따라 손쉽게 변경할 수 있으면 좋겠다.
- 이런 외부 서비스 연결에 필요한 정보는 자바 클래스에서 제거하고 손쉽게 편집할 수 있고 빌드 작업이 따로 필요없는 XML이나 프로퍼티 파일 같은 텍스트 파일에 저장해두는 편이 낫다.

### `@PropertySource`

- 프로퍼티에 들어갈 DB 연결정보는 텍스트로 된 이름과 값의 쌍으로 구성하면 된다.
- 복잡한 XML을 정의해서 사용할 것 없이 간단한 자바의 프로퍼티 파일 포맷을 이용하면 충분하다.
    - 최근엔 YAML포맷을 사용한다.

```yaml
db:
  driverClass: 'com.mysql.jdbc.Driver'
  url: 'jdbc:mysql://localhost/springbook?characterEncoding=UTF-8'
  username: spring
  password: book
```

```java
@Configuration
@EnableTransactionManagement
@ComponentScan(basePackages = ["io.undefcat.chapter0105"])
@Import(AppContext.ProductionAppContext::class)
@PropertySource("application.yml")
class AppContext {

    @Configuration
    @Profile("production")
    class ProductionAppContext {
        // ...
    }

    @Configuration
    @Profile("test")
    class TestAppContext {
        // ...
    }


}
```

- 이 값은 컨테이너가 관리하는 `Environment` 타입의 환경 오브젝트에 저장된다.
- `@Autowired`를 통해 DI 받을 수 있어서, 유용하게 사용할 수 있다.

![](list-7-124.jpeg)

### `PropertySourcesPlaceholderConfigurer`

- `Environment` 오브젝트를 DI 받아서 프로퍼티 정보를 가져오는 방법 말고, 프로퍼티 값을 직접 DI 받을 수도 있다.
- `@Value` 애노테이션을 이용하면 된다.

![](list-7-125.jpeg)

- `@Value`와 치환자를 이용해 프로퍼티 값을 필드에 주입하려면 특별한 빈을 하나 선언해줘야 한다.
- 프로퍼티 소스로부터 가져온 값을 `@Value` 필드에 주입하는 기능을 제공해주는 `PropertySourcesPlaceholderConfigurer`를 빈으로 정의해줘야 한다.

![](list-7-126.jpeg)

- 빈 팩토리 후처리기로 사용되는 빈을 정의해주는 것인데 이 빈 설정 메서드는 반드시 정적 메서드로 선언해야 한다.
- `@Value`를 이용하면 `driverClass`처럼 문자열 그대로 사용하지 않고 타입 변환이 필요한 프로퍼티를 스프링이 알아서 처리해준다는 장점이 있다.

## 7.6.6 빈 설정의 재사용과 `@Enable*`

- `SqlServiceContext`는 SQL 서비스와 관련된 빈 설정정보가 여타 빈 설정정보와 성격이 다르다고 보기 때문에 분리했다.
- 로우 레벨의 `SqlService` 구현 방법이 그대로 노출되는 빈 설정 코드를 애플리케이션의 전체 빈 구성 정보를 담은 `AppContext`에 넣는 대신 따로 분리해두는 것이 깔끔하다.
- 그뿐 아니라 SQL 서비스를 라이브러리 모듈로 뽑아내서 독립적으로 관리하고, 여러 프로젝트에서 재사용되게 하려는 이유도 있다.
- XML 같은 외부 리소스에 DAO에서 사용할 SQL을 저장해두고 필요에 따라 손쉽게 변경할 수 있게 만들면 매우 유용하다.
- SQL 서비스 빈은 서비스 인터페이스, 즉 API인 `SqlService`만 DAO에 노출하면 되고 나머지 구현 기술이나 방법은 내부에 감춰두고 필요에 따라 자유롭게 변경할 수 있어야 한다.
- SQL 서비스의 구현 클래스들은 애플리케이션의 다른 빈에 의존하지 않기 때문에 얼마든지 독립적으로 패키징해서 배포가 가능하다.
- OXM과 내장형 DB 등을 활용해 만든 SQL 서비스를 적용하려면 네 개의 빈 설정이 필요하다.
- 클래스와 인터페이스, 스키마 파일 등은 패키지를 독립적으로 바꾼 뒤에 jar 파일로 묶어서 제공하면 되지만 빈 설정은 프로젝트마다 다시 해줘야 하는 번거로움이 있다.
- 다행히 이번 절에서 SQL 서비스 관련 빈 설정을 독립적인 자바 클래스로 만들어뒀기 때문에 빈 설정정보도 라이브러리에 함께 패키징해서 제공할 수 있게 됐다.
- SQL 서비스를 사용하고 싶은 프로젝트라면 `@Import` 한 줄만 추가해주면 된다.

```java
@Import(SqlServiceContext::class)
```

### 빈 설정자

- SQL 서비스를 재사용 가능한 독립적인 모듈로 만들려면 해결할 문제가 아직 한 가지 남아 있다.
- 설정정보를 특정 경로에서 가져오는 코드가 문제다.

![](list-7-128.jpeg)

- 따라서 SQL 매핑 리소스의 위치를 빈 클래스 외부에서 설정할 수 있게 해야 한다.
- 또한 DI 설정용 클래스인 `SqlServiceContext`까지 독립적인 모듈로 분리하려면 코드에 남아 있는 `UserDao` 의존성을 제거해야 한다.
- 이런 문제는 여러번 다뤘는데, 결국 인터페이스로 분리하여 해결하면 된다.
- 즉, `SqlServiceContext`에서 분리하고 싶은 요소들을 클라이언트 개발자가 설정할 수 있도록 인터페이스로 정의한다.

```java
public interface SqlMapConfig {
	Resource getSqlMapResource();
}
```

- 그 다음, 설정 파일에서는 인터페이스를 통해 리소스를 가져오게 하면 된다.

![](list-7-131-1.jpeg)
![](list-7-132.jpeg)

- 이제 `SqlMapConfig`를 구현한 `UserSqlMapConfig` 클래스를 빈으로 등록한다.

![](list-7-133.jpeg)

- 이처럼 설정정보를 담은 코드도 리팩토링하면 반복적으로 사용되는 부분은 수정 없이 재사용될 수 있고, 적용환경에 따라 바뀌는 부분은 인터페이스로 분리하고 DI를 통해 외부에서 주입되게 만들 수 있다.
- 그런데, 더 나아가 `UserSqlMapConfig` 클래스와 관련 빈 설정을 간단하게 하는 방법은 없을까?
- `@Configuration` 애노테이션이 달린 빈 설정으로 사용되는 `AppContext` 같은 클래스도 스프링에선 하나의 빈으로 취급된다.
- 그래서` @Autowired`를 사용할 수 있고, 그 자체로도 DI될 수 있다.
- 그렇다면, `AppContext`가 `SqlMapConfig` 인터페이스를 구현해도 문제가 없을 것이다.

![](list-7-134.jpeg)

### `@Enable*` 애노테이션

- `SqlServiceContex`t는 이제 SQL 서비스 라이브러리 모듈에 포함돼서 재사용될 수 있다.
- SQL 서비스가 필요한 애플리케이션은 메인 설정 클래스에서 `@Import`로 `SqlServiceContext` 빈 설정을 추가하고 `SqlMapConfig`을 구현해 SQL 매핑파일의 위치를 지정해주기만 하면 된다.
- 스프링 3.1은 `SqlServiceContext`처럼 모듈화된 빈 설정을 가져올 때 사용하는 `@Import`를 다른 애노테이션으로 대체할 수 있는 방법을 제공한다.
- `@Component`는 빈 자동등록 대상을 지정할 때 사용하는 애노테이션인데, 많은 경우 `@Component`를 직접 사용하기보다는 `@Repository`나 `@Service`처럼 좀 더 의미 있는 이름의 애노테이션을 만들어 사용한다.
- `@Component`를 메타 애노테이션으로 넣어서 애노테이션을 정의해주면 `@Component`와 동일한 빈 등록기능이 적용되면서 자동등록되는 빈의 종류나 계층이 무엇인지 나타낼 수도 있고, AOP를 이용해 특정 애노테이션이 달린 빈만 선정해 부가기능을 제공하게 만들 수도 있다.
- 비슷한 방식으로 `@Import`도 다른 이름의 애노테이션으로 대체 가능하다.

![](list-7-135.jpeg)

- 이를 `AppContext`의 `@Import` 대신 적용할 수 있다.

![](list-7-137.jpeg)

